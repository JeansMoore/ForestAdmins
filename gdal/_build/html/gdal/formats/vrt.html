
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF8" />
    
    <title>Format virtuel de GDAL &mdash; GDAL v1.9.0 documentation</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.9.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <link rel="top" title="GDAL v1.9.0 documentation" href="../../index.html" />
    <link rel="up" title="Formats" href="index.html" />
    <link rel="next" title="WCS – OGC Web Coverage Service" href="wcs.html" />
    <link rel="prev" title="USGSDEM – USGS ASCII DEM (et CDED)" href="usgsdem.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="wcs.html" title="WCS – OGC Web Coverage Service"
             accesskey="N">suivant</a></li>
        <li class="right" >
          <a href="usgsdem.html" title="USGSDEM – USGS ASCII DEM (et CDED)"
             accesskey="P">précédent</a> |</li>
        <li><a href="../../index.html">GDAL v1.9.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >GDAL</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Formats</a> &raquo;</li> 
      </ul>
    </div>


      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table des matières</a></h3>
            <ul>
<li><a class="reference internal" href="#">Format virtuel de GDAL</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#format-vrt">Format .vrt</a></li>
<li><a class="reference internal" href="#description-des-vrt-pour-les-fichiers-brutes">Description des .vrt pour les fichiers brutes</a></li>
<li><a class="reference internal" href="#creation-programmee-de-jeux-de-donnees-vrt">Création programmée de jeux de données VRT</a></li>
<li><a class="reference internal" href="#utilisation-des-bandes-derivees">Utilisation des bandes dérivées</a></li>
<li><a class="reference internal" href="#ecrire-des-fonctions-pixels">Écrire des fonctions pixels</a></li>
<li><a class="reference internal" href="#problemes-de-multi-threading">Problèmes de Multi-threading</a></li>
</ul>
</li>
</ul>

            <h4>Sujet précédent</h4>
            <p class="topless"><a href="usgsdem.html"
                                  title="Chapitre précédent">USGSDEM &#8211; USGS ASCII DEM (et CDED)</a></p>
            <h4>Sujet suivant</h4>
            <p class="topless"><a href="wcs.html"
                                  title="Chapitre suivant">WCS &#8211; OGC Web Coverage Service</a></p>
            <h3>Cette page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/gdal/formats/vrt.txt"
                     rel="nofollow">Montrer la source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Recherche rapide</h3>
              <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="format-virtuel-de-gdal">
<span id="gdal-gdal-formats-vrt"></span><h1>Format virtuel de GDAL<a class="headerlink" href="#format-virtuel-de-gdal" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le pilote VRT est un pilote de format pour GDAL qui permet de créer des jeux de
données GDAL virtuel à partir d&#8217;autres jeux de données GDAL avec des
repositionnements et potentiellement des algorithmes appliqués ainsi que divers
types d&#8217;ajout et de modification de méta-données. Les descriptions VRT des jeux
de données peuvent être sauvé dans un format XML avec l&#8217;extension .vrt.</p>
<p>Un exemple d&#8217;un fichier .vrt simple se référent à un jeu de données de 512x512
avec une bande chargé à partir d&#8217;un fichier <em>utm.tif</em> ressemblerait à ceci :</p>
<div class="highlight-python"><pre>&lt;VRTDataset rasterXSize="512" rasterYSize="512"&gt;
&lt;GeoTransform&gt;440720.0, 60.0, 0.0, 3751320.0, 0.0, -60.0&lt;/GeoTransform&gt;
&lt;VRTRasterBand dataType="Byte" band="1"&gt;
    &lt;ColorInterp&gt;Gray&lt;/ColorInterp&gt;
    &lt;SimpleSource&gt;
    &lt;SourceFilename relativeToVRT="1"&gt;utm.tif&lt;/SourceFilename&gt;
    &lt;SourceBand&gt;1&lt;/SourceBand&gt;
    &lt;SrcRect xOff="0" yOff="0" xSize="512" ySize="512"/&gt;
    &lt;DstRect xOff="0" yOff="0" xSize="512" ySize="512"/&gt;
    &lt;/SimpleSource&gt;
&lt;/VRTRasterBand&gt;
&lt;/VRTDataset&gt;</pre>
</div>
<p>De nombreux aspects des fichiers VRT sont la conséquence directe de l&#8217;encodage
XML du modèle de données de GDAL qui devraient être revus pour la compréhension
de la sémantique des différents éléments.</p>
<p>Les fichiers VRT peuvent être produit par traduction vers le format VRT. Le
fichier résultat peut alors être édité pour modifier la cartographie, ajouter
des méta-données ou d&#8217;autres choses. Les fichiers VRT peuvent aussi être produit
par programmation de diverses manières.</p>
<p>Cette section couvrira le format de fichier .vrt (appropriée pour les
utilisateurs éditant des fichiers .vrt), et comment les fichiers .vrt peuvent
être crée et manipulé par programmation pour les développeurs.</p>
</div>
<div class="section" id="format-vrt">
<h2>Format .vrt<a class="headerlink" href="#format-vrt" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les fichiers virtuels stockés sur le disque sont laissé au format XML avec les
éléments suivants :</p>
<ul>
<li><p class="first"><strong>VRTDataset :</strong> c&#8217;est l&#8217;élément racine pour l&#8217;ensemble du jeu de données
GDAL. Il doit avoir les attributs rasterXSize et rasterYSize décrivant la
largeur et la hauteur du jeu de données en pixels. Il peut avoir des
sous-éléments SRS, GeoTransform, GCPList, Metadata, MaskBand et VRTRasterBand.</p>
<div class="highlight-python"><pre>&lt;VRTDataset rasterXSize="512" rasterYSize="512"&gt;</pre>
</div>
<p>Les sous-éléments autorisés pour VRTDataset sont :</p>
<blockquote>
<div><ul>
<li><p class="first"><strong>SRS :</strong> cet élément contient le système de référence spatial (système de
coordonnées) au format WKT de l&#8217;OGC. Notez qu&#8217;il doit être échappé pour le
XML, ainsi les items comme les guillemets auront les séquences esperluette
(&amp;) d&#8217;échappement substitué. De même, le WKT, et les méthodes
<em>SetFromUserInput()</em> valide en entrée (tel que les noms well known GEOGCS, et
le format PROJ.4) est également autorisé dans l&#8217;élément SRS.</p>
<div class="highlight-python"><pre>&lt;SRS&gt;PROJCS[&amp;quot;NAD27 / UTM zone
11N&amp;quot;,GEOGCS[&amp;quot;NAD27&amp;quot;,DATUM[&amp;quot;North_American_Datum_1927&amp;quot;,SPHEROID[&amp;quot;Clarke
1866&amp;quot;,6378206.4,294.9786982139006,AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;7008&amp;quot;]],AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;6267&amp;quot;]],PRI
MEM[&amp;quot;Greenwich&amp;quot;,0],UNIT[&amp;quot;degree&amp;quot;,0.0174532925199433],AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;4267&amp;quot;]],PROJECTION[&amp;quo
t;Transverse_Mercator&amp;quot;],PARAMETER[&amp;quot;latitude_of_origin&amp;quot;,0],PARAMETER[&amp;quot;central_meridian&amp;quot;,-117],PARAMETER[&amp;quot;
scale_factor&amp;quot;,0.9996],PARAMETER[&amp;quot;false_easting&amp;quot;,500000],PARAMETER[&amp;quot;false_northing&amp;quot;,0],UNIT[&amp;quot;metre&amp;quot;,
1,AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;9001&amp;quot;]],AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;26711&amp;quot;]]&lt;/SRS&gt;</pre>
</div>
</li>
<li><p class="first"><strong>GeoTransform :</strong> cet élément contient une transformation spatiales affine à
6 valeurs pour le jeu de données, créant une cartographie entre les
coordonnées en pixel/ligne et les coordonnées géoréférencées.</p>
<div class="highlight-python"><pre>&lt;GeoTransform&gt;440720.0,  60,  0.0,  3751320.0,  0.0, -60.0&lt;/GeoTransform&gt;</pre>
</div>
</li>
<li><p class="first"><strong>Metadata :</strong> cet élément contient une liste de pair nom/valeur de
méta-données associé à VRTDataset comme un tout, ou à VRTRasterBand. Il a un
sous-élément &lt;MDI&gt; (méta-données item) qui possède un attribut &#8220;key&#8221; et la
valeur comme une donnée de cet élément.</p>
<div class="highlight-python"><pre>&lt;Metadata&gt;
    &lt;MDI key="md_key"&gt;Metadata value&lt;/MDI&gt;
&lt;/Metadata&gt;</pre>
</div>
</li>
<li><p class="first"><strong>MaskBand :</strong> (GDAL &gt;= 1.8.0) cet élément représente une bande de masque
qui est partagé entre toutes les bandes sur le jeu de données (voir GMF_PER_DATASET
dans RFC 15). Il doit contenir un seul élément enfant VRTRasterBand, qui est
la description de la bande du masque lui-même.</p>
<div class="highlight-python"><pre>&lt;MaskBand&gt;
    &lt;VRTRasterBand dataType="Byte"&gt;
    &lt;SimpleSource&gt;
        &lt;SourceFilename relativeToVRT="1"&gt;utm.tif&lt;/SourceFilename&gt;
        &lt;SourceBand&gt;mask,1&lt;/SourceBand&gt;
        &lt;SrcRect xOff="0" yOff="0" xSize="512" ySize="512"/&gt;
        &lt;DstRect xOff="0" yOff="0" xSize="512" ySize="512"/&gt;
    &lt;/SimpleSource&gt;
    &lt;/VRTRasterBand&gt;
&lt;/MaskBand&gt;</pre>
</div>
</li>
<li><p class="first"><strong>VRTRasterBand</strong> : il représente une bande du jeu de données. il aura un
attribut dataType avec le type de données pixel associé à cette bande (utilise
les termes de Byte, UInt16, Int16, UInt32, Int32, Float32, Float64, CInt16,
CInt32, CFloat32 ou CFloat64) et la bande que cete élément représente (1
based). Cet élément peut avoir des sous-éléments Metadata, ColorInterp,
NoDataValue, HideNoDataValue, ColorTable, Description et MaskBand ainsi que diverses éléments sources
tel que SimpleSource, ComplexSource, etc. Une bande raster peut avoir plusieurs « sources »
indiquant d&#8217;où les données du raster réel doivent être recherché, et comment
il doit être drapé dans l&#8217;espace des pixels des bandes du raster.</p>
</li>
</ul>
<p>Les sous-éléments autorisés pour VRTRasterBand sont :</p>
<blockquote>
<div><ul>
<li><p class="first"><strong>ColorInterp :</strong> la données de cet élément doit être le nom d&#8217;un type
d&#8217;interprétation de couleur . Un parmi <em>Gray</em>, <em>Palette</em>, <em>Red</em>, <em>Green</em>,
<em>Blue</em>, <em>Alpha</em>, <em>Hue</em>, <em>Saturation</em>, <em>Lightness</em>, <em>Cyan</em>, <em>Magenta</em>,
<em>Yellow</em>, <em>Black</em>, ou <em>Unknown</em>.</p>
<div class="highlight-python"><pre>&lt;ColorInterp&gt;Gray&lt;/ColorInterp&gt;:</pre>
</div>
</li>
<li><p class="first"><strong>NoDataValue :</strong>  élément existe une bande raster a une valeur <em>nodata</em> associé
à la valeur données dans cet élément.</p>
<div class="highlight-python"><pre>&lt;NoDataValue&gt;-100.0&lt;/NoDataValue&gt;</pre>
</div>
</li>
<li><p class="first"><strong>HideNoDataValue :</strong> si cette valeur est 1, la valeur <em>nodata</em> ne sera
pas renvoyée. Essentiellement, le <em>caller</em> ne sera pas au courant du
pixel <em>nodata</em> quand il en lit un. Tout jeux de données copié/traduit
à partir de celui-ci n&#8217;aura pas de valeur <em>nodata</em>. Ceci est utile
lorsque vous voulez spécifier une valeur d&#8217;arrière plan fixe pour
le jeu de données. L&#8217;arrière plan sera la valeur définie par l&#8217;élément
NoDataValue.</p>
<p>La valeur par défaut est 0 quand cet élément est absent.</p>
<div class="highlight-python"><pre>&lt;HideNoDataValue&gt;1&lt;/HideNoDataValue&gt;</pre>
</div>
</li>
<li><p class="first"><strong>ColorTable :</strong> cet élément est un parent d&#8217;élément Entry définissant les
entrées dans une table de couleur. Pour l&#8217;instant seul les tables de couleurs
RVBA sont gérées avec c1 correspondant au rouge, c2 au vert, c3 au bleu et
c4 au canal alpha. Les entrées sont ordonnées et sont présumé démarrer à
l&#8217;entrée  0 de la table de couleur.</p>
<div class="highlight-python"><pre>&lt;ColorTable&gt;
&lt;Entry c1="0" c2="0" c3="0" c4="255"/&gt;
&lt;Entry c1="145" c2="78" c3="224" c4="255"/&gt;
&lt;/ColorTable&gt;</pre>
</div>
</li>
<li><p class="first"><strong>Description :</strong> cet élément contient la description optionnelle d&#8217;une
bande raster au format texte.</p>
<div class="highlight-python"><pre>&lt;Description&gt;Crop Classification Layer&lt;/Description&gt;</pre>
</div>
</li>
<li><p class="first"><strong>UnitType :</strong> cet élément optionnel contient l&#8217;unité vertical pour les
données de la bande d&#8217;élévation. Un parmi &#8220;m&#8221; pour mètres ou &#8220;ft&#8221; pour feet.
Par défaut les mètres sont utilisé.</p>
<div class="highlight-python"><pre>&lt;UnitType&gt;ft&lt;/UnitType&gt;</pre>
</div>
</li>
<li><p class="first"><strong>Offset :</strong> cet élément optionnel contient l&#8217;offset qui doit être appliqué
lors du calcul des pixel réel à partir des valeurs du pixel sur une bande
raster. 0.0 par défaut.</p>
<div class="highlight-python"><pre>&lt;Offset&gt;0.0&lt;/Offset&gt;</pre>
</div>
</li>
<li><p class="first"><strong>Scale :</strong> cet élément optionnel contient l&#8217;échelle qui doit être appliqué
lors du calcul des valeurs du pixel réel à partir des valeurs des pixels sur
une bande raster. 1.0 est la valeur par défaut.</p>
<div class="highlight-python"><pre>&lt;Scale&gt;0.0&lt;/Scale&gt;</pre>
</div>
</li>
<li><p class="first"><strong>Overview :</strong> cet élément optionnel décrit un niveau d&#8217;aperçu pour la
bande. Il doit avoir un élément enfant <em>SourceFilename</em> et <em>SourceBand</em>.
L&#8217;élément <em>SourceFilename</em> peut avoir un attribut booléen <em>relativeToVRT</em>.
Plusieurs éléments peuvent être utilisé pour décrire plusieurs aperçus.</p>
<div class="highlight-python"><pre>&lt;Overview&gt;
&lt;SourceFilename relativeToVRT="1"&gt;yellowstone_2.1.ntf.r2&lt;/SourceFilename&gt;
&lt;SourceBand&gt;1&lt;/SourceBand&gt;
&lt;/Overview&gt;</pre>
</div>
</li>
<li><p class="first"><strong>CategoryNames :</strong> cet élément optionnel contient une liste de sous-élément
de Category avec les noms des catégories pour les bandes raster classifiées.</p>
<div class="highlight-python"><pre>&lt;CategoryNames&gt;
    &lt;Category&gt;Missing&lt;/Category&gt;
    &lt;Category&gt;Non-Crop&lt;/Category&gt;
    &lt;Category&gt;Wheat&lt;/Category&gt;
    &lt;Category&gt;Corn&lt;/Category&gt;
    &lt;Category&gt;Soybeans&lt;/Category&gt;
&lt;/CategoryNames&gt;</pre>
</div>
</li>
<li><p class="first"><strong>SimpleSource :</strong> La balise <em>SimpleSource</em> indique que les données raster
doivent être lues à partir d&#8217;un jeu de données séparés, en indiquant le jeu
de données, et les bandes à partir de les lire, et comment les données doivent
être drapées dans ces bandes raster. La balise <em>SimpleSource</em> peut contenir
les sous-éléments <em>SourceFilename</em>, <em>SourceBand</em>, <em>SrcRect</em>, et <em>DstRect</em>.
L&#8217;élément <em>SrcRect</em> indiquera quel rectangle du fichier source indiqué doit
être lu, et l&#8217;élément <em>DstRect</em> indique comment le rectangle des données
sources doit être drappé dans l&#8217;espace <em>VRTRasterBands</em>.</p>
<p>L&#8217;attribut <em>relativeToVRT</em> dans l&#8217;élément <em>SourceFilename</em> indique si le nom du
fichier doit être interprété comme relatif au fichier .vrt (sa valeur est 1) ou
non relatif au fichier .vrt (sa valeur est 0). 0 par défaut.</p>
<p>Certaines caractéristiques de la bande source peuvent être définie dans la
balise optionnelle <em>SourceProperties</em> pour permettre au pilote VRT de différer
l&#8217;ouverture du jeu de données source jusqu&#8217;à ce qu&#8217;il ait réellement besoin de
lire les données. Cela est particulièrement utile lors de la construction de
VRT avec un grand nombre de jeu de données source. Les paramètres nécessaires
sont les dimensions du raster, la taille des blocs et le type de données. Si la
balise <em>SourceProperties</em> n&#8217;est pas présente, le jeu de données source sera
ouvert en même temps que le fichier VRT lui-même.</p>
<p>À partir de GDAL 1.8.0, le contenu du sous-élément <em>SourceBand</em> peut se
référer à une bande de masque. Par exemple <em>mask,1</em> signifie la bande
de masque de la première bande de la source</p>
<div class="highlight-python"><pre>&lt;SimpleSource&gt;
&lt;SourceFilename relativeToVRT="1"&gt;utm.tif&lt;/SourceFilename&gt;
&lt;SourceBand&gt;1&lt;/SourceBand&gt;
&lt;SourceProperties RasterXSize="512" RasterYSize="512" DataType="Byte" BlockXSize="128" BlockYSize="128"/&gt;
&lt;SrcRect xOff="0" yOff="0" xSize="512" ySize="512"/&gt;
&lt;DstRect xOff="0" yOff="0" xSize="512" ySize="512"/&gt;
&lt;/SimpleSource&gt;</pre>
</div>
</li>
<li><p class="first"><strong>AveragedSource :</strong> <em>AveragedSource</em> est dérivé de <em>SimpleSource</em> et partage
les mêmes propriétés sauf qu&#8217;il utilise un réechentillonnage moyen au lieu de
l&#8217;algorithme de plus proche voisin comme dans <em>SimpleSource</em>, quand la taille
du rectangle de destination n&#8217;est pas le même que la taille du rectangle source.</p>
</li>
<li><p class="first"><strong>ComplexSource :</strong> le paramètre <em>ComplexSource</em> est dérivé de <em>SimpleSource</em>
(il partage donc les éléments <em>SourceFilename</em>, <em>SourceBand</em>, <em>SrcRect</em> et
<em>DestRect</em>), mais il fournit la gestion du reéchentillonage et l&#8217;écart des
valeurs source. Certaines zones de la source peuvent être masquées en
définissant la valeur <em>NODATA</em>.</p>
<p>Le paramètre <em>ComplexSource</em> gère l&#8217;ajout de table lookup (LUK)
personnalisée pour transformer les valeurs sources vers la destination. Les LUT
peuvent être définie en utilisant la forme suivante :</p>
<div class="highlight-python"><pre>&lt;LUT&gt;[src valeur 1]:[dest valeur 1],[src valeur 2]:[dest valeur 2],...&lt;/LUT&gt;</pre>
</div>
<p>Les valeurs intermédiaire sont calculées en utilisant une interpolation linéaire
entre les valeurs de destination de liaison du domaine correspondant.</p>
<p>Le paramètre <em>ComplexSource</em> gère la recherche de composant de couleur d&#8217;une
bande raster source qui possède une table de couleur. La valeur
<em>ColorTableComponent</em> est l&#8217;index du composant de couleur à extraire : 1 pour la
bande rouge, 2 pour la bande verte, 3 pour la bande bleue ou 4 pour la bande alpha.</p>
<p>Lors de la transformation des valeurs sources les opérations sont exécutées dans
l&#8217;ordre suivant :</p>
<ol class="arabic simple">
<li>masquage des Nodata ;</li>
<li>expansion de la table de couleur ;</li>
<li>application du ratio d&#8217;échelle ;</li>
<li>application du décalage d&#8217;échelle ;</li>
<li>lecture de la table.</li>
</ol>
<div class="highlight-python"><pre>&lt;ComplexSource&gt;
&lt;SourceFilename relativeToVRT="1"&gt;utm.tif&lt;/SourceFilename&gt;
&lt;SourceBand&gt;1&lt;/SourceBand&gt;
&lt;ScaleOffset&gt;0&lt;/ScaleOffset&gt;
&lt;ScaleRatio&gt;1&lt;/ScaleRatio&gt;
&lt;ColorTableComponent&gt;1&lt;/ColorTableComponent&gt;
&lt;LUT&gt;0:0,2345.12:64,56789.5:128,2364753.02:255&lt;/LUT&gt;
&lt;NODATA&gt;0&lt;/NODATA&gt;
&lt;SrcRect xOff="0" yOff="0" xSize="512" ySize="512"/&gt;
&lt;DstRect xOff="0" yOff="0" xSize="512" ySize="512"/&gt;
&lt;/ComplexSource&gt;</pre>
</div>
</li>
<li><p class="first"><strong>KernelFilteredSource :</strong> c&#8217;est un pixel source dérivé de Simple Source (il
partage donc les éléments SourceFilename, SourceBand, SrcRect et DestRect
éléments), mais il passe également les données à travers un simple filtre
définie avec l&#8217;élément Kernel. L&#8217;élément Kernel doit avoir deux éléments
enfants, Size et Coefs et en option l&#8217;attribut booléen normalisé (par défaut
à false=0). La taille doit doit toujours être un nombre impair, et la
paramètre Coefs doit contenir Size * Size entrées séparées par des espaces.</p>
<div class="highlight-python"><pre>&lt;KernelFilteredSource&gt;
&lt;SourceFilename&gt;/debian/home/warmerda/openev/utm.tif&lt;/SourceFilename&gt;
&lt;SourceBand&gt;1&lt;/SourceBand&gt;
&lt;Kernel normalized="1"&gt;
    &lt;Size&gt;3&lt;/Size&gt;
    &lt;Coefs&gt;0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111&lt;/Coefs&gt;
&lt;/Kernel&gt;
&lt;/KernelFilteredSource&gt;</pre>
</div>
</li>
<li><p class="first"><strong>MaskBand :</strong> (GDAL &gt;= 1.8.0) cet élément représente une bande de masque
qui est spécifique à <em>VRTRasterBand</em> qu&#8217;il contient. Il doit contenir un
seule élément enfant <em>VRTRasterBand</em>, qui est la description de la bande
de masque lui-même.</p>
</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="description-des-vrt-pour-les-fichiers-brutes">
<h2>Description des .vrt pour les fichiers brutes<a class="headerlink" href="#description-des-vrt-pour-les-fichiers-brutes" title="Lien permanent vers ce titre">¶</a></h2>
<p>Jusqu&#8217;ici nous avons décris comment dérivé de nouveaux jeux de données à partir
de fichiers existants  géré par GDAL. Cependant, il est également commun d&#8217;avoir
à utiliser des fichiers raster binaires brutes pour lesquels la structure des
données est connus mais pour lequel aucun pilote spécifique à ce format n&#8217;existe.
Cela peut être accomplit en écrivant un fichier .vrt décrivant le fichier brute.</p>
<p>Par exemple, le fichier .vrt suivant décrit un fichier raster brute contenant
des pixels complexes en point flottant dans un fichier appelé <em>l2p3hhsso.img</em>.
Les données images débutent à partir du premier byte (<tt class="docutils literal"><span class="pre">mageOffset=0</span></tt>). La distance
des bytes entre les pixels est de 8 (<tt class="docutils literal"><span class="pre">PixelOffset=8</span></tt>), la taille d&#8217;un <em>Cfloat32</em>.
La distance es bytes du début d&#8217;une ligne au début de la suivante est de 9376
bytes (<tt class="docutils literal"><span class="pre">LineOffset=9376</span></tt>) ce qui correspond à la largeur (1172) fois la taille
d&#8217;un pixel (8).</p>
<div class="highlight-python"><pre>&lt;VRTDataset rasterXSize="1172" rasterYSize="1864"&gt;
    &lt;VRTRasterBand dataType="CFloat32" band="1" subClass="VRTRawRasterBand"&gt;
        &lt;SourceFilename relativetoVRT="1"&gt;l2p3hhsso.img&lt;/SourceFilename&gt;
        &lt;ImageOffset&gt;0&lt;/ImageOffset&gt;
        &lt;PixelOffset&gt;8&lt;/PixelOffset&gt;
        &lt;LineOffset&gt;9376&lt;/LineOffset&gt;
        &lt;ByteOrder&gt;MSB&lt;/ByteOrder&gt;
    &lt;/VRTRasterBand&gt;
&lt;/VRTDataset&gt;</pre>
</div>
<p>Il est à noter que  VRTRasterBand a un déterminant subClass de &#8220;VRTRawRasterBand&#8221;.
Également,  VRTRawRasterBand contient un nombre d&#8217;éléments non vue précédemment
mais aucune information « source ».  VRTRawRasterBands peut ne jamais avoir de
sources (c&#8217;est à dire  SimpleSource), mais doit contenir les éléments suivants
en plus de tous les éléments de méta-données précédemment décrit qui sont encore
géré.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SourceFilename</span></tt> : le nom du ficher brute contenant les données pour cette
bande. L&#8217;attribut relativeToVRT peut être utilisé pour indiquer si
SourceFilename est relative au fichier .vrt (1) ou non (0).</li>
<li><tt class="docutils literal"><span class="pre">ImageOffset</span></tt> : la distance en bytes du début du premier pixel de données de
cette bande d&#8217;image.  Zéro par défaut.</li>
<li><tt class="docutils literal"><span class="pre">PixelOffset</span></tt> : la distance en bytes du début d&#8217;un pixel et du suivant sur
la même ligne. Dans des données simples en paquet (packed single band) cela
correspondra à la taille de dataType en bytes.</li>
<li><tt class="docutils literal"><span class="pre">LineOffset</span></tt> : la distance en bytes du début de la ligne de données et de
la suivante. Dans les  données simple en paquet (packed single band) cela
correspondra à PixelOffset * rasterXSize.</li>
<li><tt class="docutils literal"><span class="pre">ByteOrder</span></tt> : définie l&#8217;ordre des bytes des données sur le disque. Soit
LSB (<em>Least Significant Byte first</em>) tel que l&#8217;ordre naturel sur les systèmes
Intel x86 systems ou MSB (<em>Most Significant Byte first</em>) tel que sur les systèmes
Motorola ou Sparc systems. Par défaut celui de l&#8217;ordre de la machine locale.</li>
</ul>
<p><strong>D&#8217;autre remarques :</strong></p>
<p>Les données de l&#8217;image sur le disque sont supposées être du même type de
données que la bande dataType de <em>VRTRawRasterBand</em>.
Tous les attributs ne venant pas de la source du <em>VRTRasterBand</em> sont gérés,
incluant les tables de couleurs, les méta-données, et l&#8217;interprétation des couleurs.</p>
<p><em>VRTRawRasterBand</em> gère la mise à jour du raster alors que la source basé sur
<em>VRTRasterBand</em> est toujours en lecture seule.
L&#8217;outil OpenEV inclut un menu Fichier pour entrer des paramètres décrivant le
fichier raster brute dans nue interface graphique et créer le fichier .vrt
correspondant.</p>
<p>Les bandes multiples dans un fichier .vrt peuvent venir du même fichier brute.
Assurez vous juste que les définitions <em>ImageOffset</em>, <em>PixelOffset</em>, et <em>LineOffset</em>
pour chaque bande sont appropriées pour le pixel de cette bande particulière.
Un autre exemple, dans ce cas une image de pixel entrelacé de 400x300 RVB.</p>
<div class="highlight-python"><pre>&lt;VRTDataset rasterXSize="400" rasterYSize="300"&gt;
    &lt;VRTRasterBand dataType="Byte" band="1" subClass="VRTRawRasterBand"&gt;
        &lt;ColorInterp&gt;Red&lt;/ColorInterp&gt;
        &lt;SourceFilename relativetoVRT="1"&gt;rgb.raw&lt;/SourceFilename&gt;
        &lt;ImageOffset&gt;0&lt;/ImageOffset&gt;
        &lt;PixelOffset&gt;3&lt;/PixelOffset&gt;
        &lt;LineOffset&gt;1200&lt;/LineOffset&gt;
    &lt;/VRTRasterBand&gt;
    &lt;VRTRasterBand dataType="Byte" band="2" subClass="VRTRawRasterBand"&gt;
        &lt;ColorInterp&gt;Green&lt;/ColorInterp&gt;
        &lt;SourceFilename relativetoVRT="1"&gt;rgb.raw&lt;/SourceFilename&gt;
        &lt;ImageOffset&gt;1&lt;/ImageOffset&gt;
        &lt;PixelOffset&gt;3&lt;/PixelOffset&gt;
        &lt;LineOffset&gt;1200&lt;/LineOffset&gt;
    &lt;/VRTRasterBand&gt;
    &lt;VRTRasterBand dataType="Byte" band="3" subClass="VRTRawRasterBand"&gt;
        &lt;ColorInterp&gt;Blue&lt;/ColorInterp&gt;
        &lt;SourceFilename relativetoVRT="1"&gt;rgb.raw&lt;/SourceFilename&gt;
        &lt;ImageOffset&gt;2&lt;/ImageOffset&gt;
        &lt;PixelOffset&gt;3&lt;/PixelOffset&gt;
        &lt;LineOffset&gt;1200&lt;/LineOffset&gt;
    &lt;/VRTRasterBand&gt;
&lt;/VRTDataset&gt;</pre>
</div>
</div>
<div class="section" id="creation-programmee-de-jeux-de-donnees-vrt">
<h2>Création programmée de jeux de données VRT<a class="headerlink" href="#creation-programmee-de-jeux-de-donnees-vrt" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le pilote VRT gère plusieurs méthodes de création de jeux de données VRT. En
tant que partie de GDAL 1.2.0 le fichier inclue <em>vrtdataset.h</em> doit être installé
avec les fichiers inclues coeur de GDAL, permettant un accès direct au fichier
aux classes VRT. Cependant, même sans cela, la plupart des possibilités
resteront disponible à travers les interfaces standards de GDAL.</p>
<p>Pour créer un jeu de données VRT qui est un clone d&#8217;un jeu de données existants
utilisez la méthode <em>CreateCopy()</em>. Par exemple pour cloner utm.tif dans un
fichier wrk.vrt en C++ le code suivant pourra être utilisé :</p>
<div class="highlight-python"><pre>GDALDriver *poDriver = (GDALDriver *) GDALGetDriverByName( "VRT" );
GDALDataset *poSrcDS, *poVRTDS;

poSrcDS = (GDALDataset *) GDALOpenShared( "utm.tif", GA_ReadOnly );

poVRTDS = poDriver-&gt;CreateCopy( "wrk.vrt", poSrcDS, FALSE, NULL, NULL, NULL );

GDALClose((GDALDatasetH) poVRTDS);
GDALClose((GDALDatasetH) poSrcDS);</pre>
</div>
<p>Notez l&#8217;utilisation de <em>GDALOpenShared()</em> lors de l&#8217;ouverture du jeu de données
source. Il est conseillé d&#8217;utiliser <em>GDALOpenShared()</em> dans cette situation afin
d&#8217;être capable de publier la référence explicite à celle-ci avant de fermer le
jeu de données VRT lui-même. En d&#8217;autes mots, dans l&#8217;exemple précédent, vous
pouvez également inverser les deux dernières lignes, tandis que si vous ouvrez
le jeu de données source avec <em>GDALOpen()</em>, vous devrez fermer le jeu de données
VRT avant de fermer le jeu de données source.</p>
<p>Pour créer une copie virtuelle d&#8217;un jeu de données avec des attributs ajoutés
ou modifiés tels que les méta-données ou les systèmes de coordonnées qui sont
souvent difficile de changer dans les autres formats, vous pouvez faire ce qui
suit. Dans ce cas, le jeu de données virtuel est crée « en mémoire » seulement
par virtualisation de sa création avec un nom de fichier vide, puis utilisé
comme source modifiée pour passer à une méthode <em>CreateCopy()</em> créant le format TIFF.</p>
<div class="highlight-python"><pre>poVRTDS = poDriver-&gt;CreateCopy( "", poSrcDS, FALSE, NULL, NULL, NULL );

poVRTDS-&gt;SetMetadataItem( "SourceAgency", "United States Geological Survey");
poVRTDS-&gt;SetMetadataItem( "SourceDate", "July 21, 2003" );

poVRTDS-&gt;GetRasterBand( 1 )-&gt;SetNoDataValue( -999.0 );

GDALDriver *poTIFFDriver = (GDALDriver *) GDALGetDriverByName( "GTiff" );
GDALDataset *poTiffDS;

poTiffDS = poTIFFDriver-&gt;CreateCopy( "wrk.tif", poVRTDS, FALSE, NULL, NULL, NULL );

GDALClose((GDALDatasetH) poTiffDS);</pre>
</div>
<p>Dans les exemples ci-dessus la valeur <em>nodata</em> est définie à -999. Vous pouvez
définir l&#8217;élément <em>HideNoDataValue</em> dans la bande du jeu de données VRT en
utilisant <em>SetMetadataItem()</em> sur cette bande.</p>
<div class="highlight-python"><pre>poVRTDS-&gt;GetRasterBand( 1 )-&gt;SetMetadataItem( "HideNoDataValue" , "1" );</pre>
</div>
<p>Dans cet exemple, un jeu de données est crée avec la méthode Create(), et on
ajoute des bandes et des sources par programmation, mais toujours à l&#8217;aide de
l&#8217;API « générique ». Un attribut spécial des jeux de données VRT permet
d&#8217;ajouter des sources aux VRTRasterBand (mais pas à VRTRawRasterBand) en passant
le XML décrivant la source dans <em>SetMetada()</em> sur la cible du domaine spécial
« new_vrt_sources ». Le domaine cible « vrt_sources » peut également être utilisé,
auquel cas n&#8217;importe quelle source  sera rejetée avant d&#8217;en ajouter de nouvelle.
Dans cet exemple nous construisons un simple filtre moyen  à la place de source
simple.</p>
<div class="highlight-python"><pre>// construct XML for simple 3x3 average filter kernel source.
const char *pszFilterSourceXML  =
"&lt;KernelFilteredSource&gt;"
"  &lt;SourceFilename&gt;utm.tif&lt;/SourceFilename&gt;&lt;SourceBand&gt;1&lt;/SourceBand&gt;"
"  &lt;Kernel&gt;"
"    &lt;Size&gt;3&lt;/Size&gt;"
"    &lt;Coefs&gt;0.111 0.111 0.111 0.111 0.111 0.111 0.111 0.111 0.111&lt;/Coefs&gt;"
"  &lt;/Kernel&gt;"
"&lt;/KernelFilteredSource&gt;";

// Create the virtual dataset.
poVRTDS = poDriver-&gt;Create( "", 512, 512, 1, GDT_Byte, NULL );
poVRTDS-&gt;GetRasterBand(1)-&gt;SetMetadataItem("source_0",pszFilterSourceXML",
                                            "new_vrt_sources");</pre>
</div>
<p>Une manière plus générale de cela et qui produira un clone 3x3 moyen de
n&#8217;importe quelle source de données en entrée pourrait ressembler à ce qui suit.
Dans ce cas nous définissons délibérément la source de données filtrée comme
dans le domaine « vrt_sources » pour écraser la SimpleSource crée par la méthode
<em>CreateCopy()</em>. Le fait que nous utilisons  CreateCopy() nous assure que tous
les autres méta-données, géoréférencement et autre seront préservé à partir du
jeu de données source ... La seule chose que nous somme en train de changer est
la source des données pour chaque bande.</p>
<div class="highlight-python"><pre>int   nBand;
GDALDriver *poDriver = (GDALDriver *) GDALGetDriverByName( "VRT" );
GDALDataset *poSrcDS, *poVRTDS;

poSrcDS = (GDALDataset *) GDALOpenShared( pszSourceFilename, GA_ReadOnly );

poVRTDS = poDriver-&gt;CreateCopy( "", poSrcDS, FALSE, NULL, NULL, NULL );

for( nBand = 1; nBand &lt;= poVRTDS-&gt;GetRasterCount(); nBand++ )
{
    char szFilterSourceXML[10000];

    GDALRasterBand *poBand = poVRTDS-&gt;GetRasterBand( nBand );

    sprintf( szFilterSourceXML,
        "&lt;KernelFilteredSource&gt;"
        "  &lt;SourceFilename&gt;%s&lt;/SourceFilename&gt;&lt;SourceBand&gt;%d&lt;/SourceBand&gt;"
        "  &lt;Kernel&gt;"
        "    &lt;Size&gt;3&lt;/Size&gt;"
        "    &lt;Coefs&gt;0.111 0.111 0.111 0.111 0.111 0.111 0.111 0.111 0.111&lt;/Coefs&gt;"
        "  &lt;/Kernel&gt;"
        "&lt;/KernelFilteredSource&gt;",
        pszSourceFilename, nBand );

    poBand-&gt;SetMetadataItem( "source_0", szFilterSourceXML, "vrt_sources" );
}</pre>
</div>
<p>La classe <em>VRTDataset</em> est une des quelques implémentations de jeux de données
qui gère la méthode <em>AddBand()</em>. Les options passées à la méthode <em>AddBand()</em>
peut être utilisées pour contrôler le type de bande créé (<em>VRTRasterBand</em>,
<em>VRTRawRasterBand</em>, <em>VRTDerivedRasterBand</em>), et dans le cas de
<em>VRTRawRasterBand</em> de définir ses différentes paramètres. Pour le standard
<em>VRTRasterBand</em>, les sources doivent être définie avec les exemples
<em>SetMetadata()</em> / <em>SetMetadataItem()</em> ci-dessus.</p>
<div class="highlight-python"><pre>GDALDriver *poDriver = (GDALDriver *) GDALGetDriverByName( "VRT" );
GDALDataset *poVRTDS;

poVRTDS = poDriver-&gt;Create( "out.vrt", 512, 512, 0, GDT_Byte, NULL );
char** papszOptions = NULL;
papszOptions = CSLAddNameValue(papszOptions, "subclass", "VRTRawRasterBand"); // if not specified, default to VRTRasterBand
papszOptions = CSLAddNameValue(papszOptions, "SourceFilename", "src.tif"); // mandatory
papszOptions = CSLAddNameValue(papszOptions, "ImageOffset", "156"); // optionnal. default = 0
papszOptions = CSLAddNameValue(papszOptions, "PixelOffset", "2"); // optionnal. default = size of band type
papszOptions = CSLAddNameValue(papszOptions, "LineOffset", "1024"); // optionnal. default = size of band type * width
papszOptions = CSLAddNameValue(papszOptions, "ByteOrder", "LSB"); // optionnal. default = machine order
papszOptions = CSLAddNameValue(papszOptions, "RelativeToVRT", "true"); // optionnal. default = false
poVRTDS-&gt;AddBand(GDT_Byte, papszOptions);
CSLDestroy(papszOptions);

delete poVRTDS;</pre>
</div>
</div>
<div class="section" id="utilisation-des-bandes-derivees">
<h2>Utilisation des bandes dérivées<a class="headerlink" href="#utilisation-des-bandes-derivees" title="Lien permanent vers ce titre">¶</a></h2>
<p>Un type de bande spécialisé est une bande &#8216;dérivée&#8217; qui dérive ses informations
des pixels de ses bandes sources. Avec ce type de bande vous devez définir une
fonction pixel, qui a la responsabilité de générer le raster de sortie. Les
fonctions pixel sont crée par une application puis enregistré avec GDAL en
utilisant une clé unique.</p>
<p>En utilisant des bandes dérivées vous pouvez créer des jeux de données VRT qui
manipule des bandes à la volées sans créer de nouveau fichier de bandes sur le
disque. Par exemple, vous pouvez générer une bande en utilisant 4 bandes source
à partir d&#8217;une neuvième bande d&#8217;un jeu de données en entré (x0, x3, x4, et x8) :
band_value = sqrt((x3*x3+x4*x4)/(x0*x8));</p>
<p>Vous pouvez écrire la fonction pixel pour calculer cette valeur puis
l&#8217;enregistrer avec GDAL avec le nom « MyPremiereFonction ». Puis, le fichier
XML VRT suivant pourra être utilisé pour afficher cette bande dérivée :</p>
<div class="highlight-python"><pre>&lt;VRTDataset rasterXSize="1000" rasterYSize="1000"&gt;
    &lt;VRTRasterBand dataType="Float32" band="1" subClass="VRTDerivedRasterBand"&gt;&gt;
        &lt;Description&gt;Magnitude&lt;/Description&gt;
        &lt;PixelFunctionType&gt;MyFirstFunction&lt;/PixelFunctionType&gt;
        &lt;SimpleSource&gt;
            &lt;SourceFilename relativeToVRT="1"&gt;nine_band.dat&lt;/SourceFilename&gt;
            &lt;SourceBand&gt;1&lt;/SourceBand&gt;
            &lt;SrcRect xOff="0" yOff="0" xSize="1000" ySize="1000"/&gt;
            &lt;DstRect xOff="0" yOff="0" xSize="1000" ySize="1000"/&gt;
        &lt;/SimpleSource&gt;
        &lt;SimpleSource&gt;
            &lt;SourceFilename relativeToVRT="1"&gt;nine_band.dat&lt;/SourceFilename&gt;
            &lt;SourceBand&gt;4&lt;/SourceBand&gt;
            &lt;SrcRect xOff="0" yOff="0" xSize="1000" ySize="1000"/&gt;
            &lt;DstRect xOff="0" yOff="0" xSize="1000" ySize="1000"/&gt;
        &lt;/SimpleSource&gt;
            &lt;SimpleSource&gt;
            &lt;SourceFilename relativeToVRT="1"&gt;nine_band.dat&lt;/SourceFilename&gt;
            &lt;SourceBand&gt;5&lt;/SourceBand&gt;
            &lt;SrcRect xOff="0" yOff="0" xSize="1000" ySize="1000"/&gt;
            &lt;DstRect xOff="0" yOff="0" xSize="1000" ySize="1000"/&gt;
        &lt;/SimpleSource&gt;
        &lt;SimpleSource&gt;
            &lt;SourceFilename relativeToVRT="1"&gt;nine_band.dat&lt;/SourceFilename&gt;
            &lt;SourceBand&gt;9&lt;/SourceBand&gt;
            &lt;SrcRect xOff="0" yOff="0" xSize="1000" ySize="1000"/&gt;
            &lt;DstRect xOff="0" yOff="0" xSize="1000" ySize="1000"/&gt;
        &lt;/SimpleSource&gt;
    &lt;/VRTRasterBand&gt;
&lt;/VRTDataset&gt;</pre>
</div>
<p>En plus de la spécification de la sous-classe ( VRTDerivedRasterBand) et la
valeur de PixelFunctionType, il y a un nouveau paramètre qui peut être utile :
sourceTransferType. Typiquement, les rasters sources sont obtenu en utilisant le
type de donnée de la bande dérivée. Parfois, il se peut que lorsque vous voulez
que la fonction pixel puisse accéder à une source de données de plus haute
résolution que le type de donnée qui est générée. Par exemple, vous pouvez avoir
une bande dérivée de type « FLOAT », qui prend une source simple de type
« CFloat32 » ou « CFloat64 » et renvoi la portion imaginaire. Pour accomplir
cela, définissez le paramètre SourceTransfertType à « CFloat64 ». Autrement la
source sera converti en « Float » avant d&#8217;appeler  la fonction pixel, et la
partie imaginaire sera perdue.</p>
<div class="highlight-python"><pre>&lt;VRTDataset rasterXSize="1000" rasterYSize="1000"&gt;
    &lt;VRTRasterBand dataType="Float32" band="1" subClass="VRTDerivedRasterBand"&gt;&gt;
        &lt;Description&gt;Magnitude&lt;/Description&gt;
        &lt;PixelFunctionType&gt;MyFirstFunction&lt;/PixelFunctionType&gt;
        &lt;SourceTransferType&gt;CFloat64&lt;/SourceTransferType&gt;
        ...</pre>
</div>
</div>
<div class="section" id="ecrire-des-fonctions-pixels">
<h2>Écrire des fonctions pixels<a class="headerlink" href="#ecrire-des-fonctions-pixels" title="Lien permanent vers ce titre">¶</a></h2>
<p>Pour enregistrer cette fonction avec GDAL (avant d&#8217;accéder à un jeu de données
VRT avec des bandes dérivées qui utilisent cette fonction), une application
appelle  <tt class="docutils literal"><span class="pre">GDALAddDerivedBandPixelFunc</span></tt> avec une clé et
<tt class="docutils literal"><span class="pre">GDALDerivedPixelFunc</span></tt> : <tt class="docutils literal"><span class="pre">GDALAddDerivedBandPixelFunc(&quot;MyFirstFunction&quot;,</span> <span class="pre">TestFunction);</span></tt></p>
<p>Le bon moment pour faire cela se situe au début d&#8217;une application quand les
pilotes GDAL sont enregistrés. GDALDerivedPixelFunc est définie avec une
signature similaire à IRasterIO :</p>
<p><strong>Paramètres :</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr><td rowspan="3">papoSources</td>
<td rowspan="3">Un pointeur pour entasser des rasters ; un par source. Tous leurs types de donnée doivent
être le même, définie dans le paramètre eSrcType.</td>
</tr>
<tr></tr>
<tr></tr>
<tr><td rowspan="2">nSources</td>
<td rowspan="2">Le nombre de source rasters.</td>
</tr>
<tr></tr>
<tr><td rowspan="5">pData</td>
<td rowspan="5">Le buffer dans lequel les données doivent être lu, ou dans lequel il doit être écrit. Ce
buffer doit contenir au moins nBufXSize * nBufYSize mots de type eBufType. L&#8217;ordre des
pixel est organisé de gauche à droite, de haut en bas. L&#8217;espacement est contrôlé par les
paramètres nPixelSpace, et nLineSpace.</td>
</tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td rowspan="3">nBufXSize</td>
<td rowspan="3">La largeur du buffer de l&#8217;image dans laquelle la région désirée doit être lue, ou dans
lequel il doit être écrit.</td>
</tr>
<tr></tr>
<tr></tr>
<tr><td rowspan="3">nBufYSize</td>
<td rowspan="3">La hauteur du buffer de l&#8217;image dans laquelle la région désirée doit être lue, ou dans
lequel il doit être écrit.</td>
</tr>
<tr></tr>
<tr></tr>
<tr><td rowspan="2">eSrcType</td>
<td rowspan="2">Le type des valeurs des pixels dans le tableau raster papoSources.</td>
</tr>
<tr></tr>
<tr><td rowspan="3">eBufType</td>
<td rowspan="3">Le type des valeurs des pixels que la fonction pixel doit générer dans le buffer de
données pData.</td>
</tr>
<tr></tr>
<tr></tr>
<tr><td rowspan="4">nPixelSpace</td>
<td rowspan="4">La distance des bytes du début de la valeur d&#8217;un pixel dans pData de la prochaine valeur
du pixel dans une ligne. Si la valeur par défaut doit être utilisée la taille du type de
données eBufType est utilisée.</td>
</tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr><td rowspan="2">nLineSpace</td>
<td rowspan="2">La distance des bytes à partir du début d&#8217;une ligne dans pData au début de la suivante.</td>
</tr>
<tr></tr>
</tbody>
</table>
<p><strong>Retour :</strong></p>
<div class="highlight-python"><pre>CE_Failure on failure, otherwise CE_None.
typedef CPLErr
(*GDALDerivedPixelFunc)(void **papoSources, int nSources, void *pData,
                    int nXSize, int nYSize,
                    GDALDataType eSrcType, GDALDataType eBufType,
                    int nPixelSpace, int nLineSpace);</pre>
</div>
<p>Ce qui suit est une implémentation de la fonction pixel :</p>
<div class="highlight-python"><pre>#include "gdal.h"

CPLErr TestFunction(void **papoSources, int nSources, void *pData,
                int nXSize, int nYSize,
                GDALDataType eSrcType, GDALDataType eBufType,
                int nPixelSpace, int nLineSpace)
{

    int ii, iLine, iCol;
    double pix_val;
    double x0, x3, x4, x8;

    // ---- Init ----
    if (nSources != 4) return CE_Failure;

    // ---- Set pixels ----
    for( iLine = 0; iLine &lt; nYSize; iLine++ )
    {
        for( iCol = 0; iCol &lt; nXSize; iCol++ )
        {
            ii = iLine * nXSize + iCol;

            /* Source raster pixels may be obtained with SRCVAL macro */
            x0 = SRCVAL(papoSources[0], eSrcType, ii);
            x3 = SRCVAL(papoSources[1], eSrcType, ii);
            x4 = SRCVAL(papoSources[2], eSrcType, ii);
            x8 = SRCVAL(papoSources[3], eSrcType, ii);

            pix_val = sqrt((x3*x3+x4*x4)/(x0*x8));

            GDALCopyWords(&amp;pix_val, GDT_Float64, 0,
                       ((GByte *)pData) + nLineSpace * iLine + iCol * nPixelSpace,
                       eBufType, nPixelSpace, 1);
         }
    }

    // ---- Return success ---- //
    return CE_None;
}</pre>
</div>
</div>
<div class="section" id="problemes-de-multi-threading">
<h2>Problèmes de Multi-threading<a class="headerlink" href="#problemes-de-multi-threading" title="Lien permanent vers ce titre">¶</a></h2>
<p>Lors de l&#8217;utilisation de jeux de données VRT dans un environnement
multi-threading, vous devez être prudent lors de l&#8217;ouverture de jeu de données
VRT par le thread qui va l&#8217;utiliser par la suite. La raison de cela est que le
jeu de données VRT utilise <em>GDALOpenShared</em> lors de l&#8217;ouverture des jeux de
données sous-jacent. Si vous ouvrez deux fois le même jeu de données VRT par le
même thread, l&#8217;ensemble des jeux de données VRT partageront la même prise en
charge des jeux de données sous-jacent.</p>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="wcs.html" title="WCS – OGC Web Coverage Service"
             >suivant</a></li>
        <li class="right" >
          <a href="usgsdem.html" title="USGSDEM – USGS ASCII DEM (et CDED)"
             >précédent</a> |</li>
        <li><a href="../../index.html">GDAL v1.9.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >GDAL</a> &raquo;</li>
          <li><a href="index.html" >Formats</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    <a href="http://creativecommons.org/licenses/by/2.0/fr/deed.fr">Licence Creative Common BY</a>
    <!--
      &copy; Copyright 2011, Yves Jacolin.-->
      Créé avec <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>