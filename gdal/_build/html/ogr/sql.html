
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF8" />
    
    <title>SQL dans OGR &mdash; GDAL v1.9.0 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.9.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="top" title="GDAL v1.9.0 documentation" href="../index.html" />
    <link rel="up" title="OGR" href="index.html" />
    <link rel="next" title="Python" href="../python/index.html" />
    <link rel="prev" title="X-Plane/Flightgear aeronautical data" href="formats/xplane.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../python/index.html" title="Python"
             accesskey="N">suivant</a></li>
        <li class="right" >
          <a href="formats/xplane.html" title="X-Plane/Flightgear aeronautical data"
             accesskey="P">précédent</a> |</li>
        <li><a href="../index.html">GDAL v1.9.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">OGR</a> &raquo;</li> 
      </ul>
    </div>


      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table des matières</a></h3>
            <ul>
<li><a class="reference internal" href="#">SQL dans OGR</a><ul>
<li><a class="reference internal" href="#syntaxe-sql-geree">Syntaxe SQL gérée</a></li>
<li><a class="reference internal" href="#select">SELECT</a><ul>
<li><a class="reference internal" href="#operateurs-de-liste-de-champs">Opérateurs de liste de champs</a></li>
<li><a class="reference internal" href="#utiliser-les-alias-des-noms-de-champs">Utiliser les alias des noms de champs</a></li>
<li><a class="reference internal" href="#changer-le-type-des-champs">Changer le type des champs</a></li>
<li><a class="reference internal" href="#where">WHERE</a></li>
<li><a class="reference internal" href="#limitations-de-la-clause-where">Limitations de la clause WHERE</a></li>
<li><a class="reference internal" href="#order-by">ORDER BY</a></li>
<li><a class="reference internal" href="#clause-join">Clause JOIN</a></li>
<li><a class="reference internal" href="#limitations-de-la-clause-join">Limitations de la clause JOIN</a></li>
</ul>
</li>
<li><a class="reference internal" href="#champs-speciaux">Champs spéciaux</a><ul>
<li><a class="reference internal" href="#fid">FID</a></li>
<li><a class="reference internal" href="#ogr-geometry">OGR_GEOMETRY</a></li>
<li><a class="reference internal" href="#ogr-geom-wkt">OGR_GEOM_WKT</a></li>
<li><a class="reference internal" href="#ogr-geom-area">OGR_GEOM_AREA</a></li>
<li><a class="reference internal" href="#ogr-style">OGR_STYLE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#create-index">CREATE INDEX</a><ul>
<li><a class="reference internal" href="#limitations-des-index">Limitations des Index</a></li>
</ul>
</li>
<li><a class="reference internal" href="#drop-index">DROP INDEX</a></li>
<li><a class="reference internal" href="#executesql">ExecuteSQL()</a></li>
<li><a class="reference internal" href="#sql-hors-ogr">SQL hors OGR</a></li>
</ul>
</li>
</ul>

            <h4>Sujet précédent</h4>
            <p class="topless"><a href="formats/xplane.html"
                                  title="Chapitre précédent">X-Plane/Flightgear aeronautical data</a></p>
            <h4>Sujet suivant</h4>
            <p class="topless"><a href="../python/index.html"
                                  title="Chapitre suivant">Python</a></p>
            <h3>Cette page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/ogr/sql.txt"
                     rel="nofollow">Montrer la source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Recherche rapide</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="sql-dans-ogr">
<span id="gdal-ogr-sql"></span><h1>SQL dans OGR<a class="headerlink" href="#sql-dans-ogr" title="Lien permanent vers ce titre">¶</a></h1>
<p><em>OGRDataSource</em> gère l&#8217;exécution de commandes en opposition à la source de
données via la méthode <em>OGRDataSource::ExecuteSQL()</em>. Bien qu&#8217;en théorie
n&#8217;importe quelle commande peut être prise en charge de cette manière, en
pratique le mécanisme est utilisé pour fournir un sous ensemble des possibilités
de SELECT de SQL aux applications. Cette page discute de l&#8217;implémentation de
SQL générique dans OGR, et des problèmes avec la gestion des SQL spécifique au
pilote.</p>
<div class="section" id="syntaxe-sql-geree">
<h2>Syntaxe SQL gérée<a class="headerlink" href="#syntaxe-sql-geree" title="Lien permanent vers ce titre">¶</a></h2>
<p>La classe <em>OGRLayer</em> gère également l&#8217;application d&#8217;un filtre de requête
attributaire aux features retournées en utilisant la méthode
<em>OGRLayer::SetAttributeFilter()</em>. La syntaxe pour le filtre attributaire est la
même que la clause WHERE dans la requête SELECT du SQL d&#8217;OGR. Donc tout ce
qui concerne ici la clause WHERE s&#8217;applique également dans le contexte de la
méthode <em>SetAttributeFilter()</em></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">OGR SQL a été implémenté pour la version 1.8.0 de GDAL/OGR. Plusieurs
fonctionnalités présentées ci-dessous, notamment les expressions arithmétiques
et les expressions dans la liste des champs, n&#8217;étaient pas gérées dans la
version 1.7.x ou plus ancienne de GDAL/OGR. Voyez la RFC 28 pour les détails
des nouvelles fonctionnalités dans la version 1.8.0 de GDAL/OGR.</p>
</div>
</div>
<div class="section" id="select">
<h2>SELECT<a class="headerlink" href="#select" title="Lien permanent vers ce titre">¶</a></h2>
<p>La requête SELECT est utilisée pour récupérer les objets d&#8217;une couche (analogue
aux lignes des tables dans un RDBMS) avec le résultat de la requête représentée
comme une couche temporaire d&#8217;objets. Les couches de la source de données sont
analogues aux tables dans un RDBMS et les attributs des objets sont analogues
aux valeurs des colonnes. La forme la plus simple d&#8217;une requête SELECT du SQL
d&#8217;OGR ressemble à cela :</p>
<div class="highlight-python"><pre>SELECT * FROM polylayer</pre>
</div>
<p>Dans ce cas tous les objets sont récupérés de la couche nommée <em>polylayer</em>, et
tous les attributs de ces objets sont renvoyés. C&#8217;est essentiellement équivalent
à accéder à la couche directement. Dans cet exemple l&#8217;&#8221;*&#8221; est la liste de tous
les champs à récupérer de la couche, avec &#8220;*&#8221; signifiant que tous les champs sont
récupérés.</p>
<p>Cette forme sensiblement plus sophistiquée renvoie encore tous les objets d&#8217;une
couche mais le schéma contiendra les attributs <em>EAS_ID</em> et <em>PROP_VALUE</em>.
N&#8217;importe quel attribut sera ignoré.</p>
<div class="highlight-python"><pre>SELECT eas_id, prop_value FROM polylayer</pre>
</div>
<p>Un SELECT un petit peu plus ambitieux, restreignant les objets récupérés avec
une clause WHERE et classant les résultats, ressemblera à ceci :</p>
<div class="highlight-python"><pre>SELECT * from polylayer WHERE prop_value &gt; 220000.0 ORDER BY prop_value DESC</pre>
</div>
<p>Cette requête SELECT produira une table avec juste un objet, avec un attribut
(nommé <em>count_eas_id</em>) contenant le nombre de valeur distincte des attributs
<em>eas_id</em>.</p>
<div class="highlight-python"><pre>SELECT COUNT(DISTINCT eas_id) FROM polylayer</pre>
</div>
<div class="section" id="operateurs-de-liste-de-champs">
<h3>Opérateurs de liste de champs<a class="headerlink" href="#operateurs-de-liste-de-champs" title="Lien permanent vers ce titre">¶</a></h3>
<p>La liste de champs est une liste séparée par des virgules de champs pour
rapporter les objets en sortie de la couche source. Ils apparaitront sur les
objets en sortie dans l&#8217;ordre où ils apparaissent dans la liste des champs,
cette liste peut donc être utilisé pour ré-ordonner les champs.</p>
<p>Une forme spéciale de la liste des champs utilise le mot-clé DISTINCT. Cela
renvoie une liste de valeurs distinctes de l&#8217;attribut nommé. Quand le mot-clé
DISTINCT est utilisé, seulement un attribut peut apparaitre dans la liste. Ce
mot-clé peut être utilisé avec n&#8217;importe quel type de champ. Pour l&#8217;instant le
test pour faire la distinction entre les valeurs est sensible à la casse dans
le SQL d&#8217;OGR. Le résultat d&#8217;un SELECT avec le mot-clé DISTINCT est une couche
avec une colonne (nommé de la même manière que le champs sur lequel la sélection
s&#8217;opère), et un objet par valeur distinct. Les géométries sont ignorées. Les
valeurs distinctes sont assemblée en mémoire, donc cela peut utiliser beaucoup
de mémoire pour des jeux de données avec un grand nombre de valeurs distinctes.</p>
<div class="highlight-python"><pre>SELECT DISTINCT areacode FROM polylayer</pre>
</div>
<p>Il y a également plusieurs opérateurs de synthèse qui peuvent être appliqués aux
colonnes. Quand un opérateur de synthèse est appliqué à un champ, alors un
opérateur de synthèse doit être appliqué sur tous les champs. Les opérateurs de
synthèses sont COUNT (compte le nombre d&#8217;instance), AVG (moyenne arithmétique),
SUM (somme numérique), MIN (sémantique ou minimum numérique) , et MAX
(sémantique ou maximum numérique). Cet exemple produit diverses informations de
synthèse sur les valeurs des propriétés des parcelles :</p>
<div class="highlight-python"><pre>SELECT MIN(prop_value), MAX(prop_value), AVG(prop_value), SUM(prop_value),
   COUNT(prop_value) FROM polylayer WHERE prov_name = "Ontario"</pre>
</div>
<p>Un cas spécial, on peut donner l&#8217;argument &#8220;*&#8221; à l&#8217;opérateur COUNT() à la place
du nom du champs qui est une forme raccourcit pour compter tous les
enregistrements bien qu&#8217;il donnera le même résultat en utilisant n&#8217;importe quels
noms de colonne. Il est également possible d&#8217;appliquer l&#8217;opérateur COUNT() à un
SELECT DISTINCT pour obtenir le nombre de valeurs distinctes, par exemple :</p>
<div class="highlight-python"><pre>SELECT COUNT(DISTINCT areacode) FROM polylayer</pre>
</div>
<p>Les noms des champs peuvent également être préfixé par le nom d&#8217;une table bien
que cela soit réellement significatif que pour les jointures. Cela est démontré
plus loin dans la section JOIN.</p>
<p>Les définitions de champs peuvent aussi être des expressions complexes en
utilisant des opérateurs arithmétiques et fonctionnels. Cependant, le mot-clé
DISTINCT, et les opérateurs d&#8217;agrégation MIN, MAX, AVG et SUM ne peuvent pas être
appliqués aux expressions de champs.</p>
<div class="highlight-python"><pre>SELECT cost+tax from invoice</pre>
</div>
<p>ou</p>
<div class="highlight-python"><pre>SELECT CONCAT(owner_first_name,' ',owner_last_name) from properties</pre>
</div>
</div>
<div class="section" id="utiliser-les-alias-des-noms-de-champs">
<h3>Utiliser les alias des noms de champs<a class="headerlink" href="#utiliser-les-alias-des-noms-de-champs" title="Lien permanent vers ce titre">¶</a></h3>
<p>SQL d&#8217;OGR gère le renommage des champs en suivant la spécifications SQL92 en
utilisant le mot-clé AS comme pour l&#8217;exemple suivant :</p>
<div class="highlight-python"><pre>SELECT *, OGR_STYLE AS 'STYLE' FROM polylayer</pre>
</div>
<p>L&#8217;alias du nom du champ peut être utilisé comme la dernière opération dans la
spécification de la colonne. Par conséquent nous ne pouvons pas renommer les
champs à l&#8217;intérieure d&#8217;un opérateur, mais nous pouvons renommer toute
l&#8217;expression de la colonne, comme ces deux exemples :</p>
<div class="highlight-python"><pre>SELECT COUNT(areacode) AS 'count' FROM polylayer
SELECT dollars/100.0 AS cents FROM polylayer</pre>
</div>
</div>
<div class="section" id="changer-le-type-des-champs">
<h3>Changer le type des champs<a class="headerlink" href="#changer-le-type-des-champs" title="Lien permanent vers ce titre">¶</a></h3>
<p>À partir de GDAL 1.6.0, SQL d&#8217;OGR gère le changement du type des colonnes en
utilisant l&#8217;opérateur CAST conforme SQL92 comme pour l&#8217;exemple suivant :</p>
<div class="highlight-python"><pre>SELECT *, CAST(OGR_STYLE AS character(255)) FROM rivers</pre>
</div>
<p>Pour l&#8217;instant la transformation vers les cibles suivantes sont gérées :</p>
<ul class="simple">
<li><em>character(field_length)</em>, field_length=1 par défaut</li>
<li><em>float(field_length)</em></li>
<li><em>numeric(field_length, field_precision)</em></li>
<li><em>integer(field_length)</em></li>
<li><em>date(field_length)</em></li>
<li><em>time(field_length)</em></li>
<li><em>timestamp(field_length)</em></li>
</ul>
<p>Définir <em>field_length</em> et/ou <em>field_precision</em> est optionel. Une valeur zéro
explicite peut être utilisée comme la largeur d&#8217;un champ character() pour indiquer
la largeur de la variable. La conversion vers les types de données OGR
&#8216;liste d&#8217;entier&#8217;, &#8216;liste double&#8217; et &#8216;liste de caractères&#8217; ne sont pas gérés, ce
qui n&#8217;est pas conforme aux spécification SQL92.</p>
<p>Bien que l&#8217;opérateur CAST peut être appliqué n&#8217;importe où dans une expression,
dont la clause WHERE, le contrôle du format du champ en sortie est seulement géré
si l&#8217;opérateur CAST est l&#8217;opérateur le plus à l&#8217;extérieur sur un champ dans une
liste de définition de champs. Dans d&#8217;autres contexte il est encore utile de
convertir entre les types de donnée numérique, chaîne et date.</p>
</div>
<div class="section" id="where">
<h3>WHERE<a class="headerlink" href="#where" title="Lien permanent vers ce titre">¶</a></h3>
<p>L&#8217;argument de la clause WHERE est une expression logique assez simpliste utilisé
pour sélectionner les enregistrements d&#8217;une couche source. En plus de cette
utilisation dans la requête WHERE, la prise en charge de la clause WHERE est
également utilisé par les requêtes attributaires d&#8217;OGR sur les couches normales
via <em>OGRLayer::SetAttributeFilter()</em>.</p>
<p>En plus des opérateurs arithmétiques et autres opérateurs fonctionnels disponibles
dans l&#8217;expression dans la clause de définition des champs de la requête SELECT, les
opérateurs logiques sont aussi disponible dans la clause WHERE et la valeur
évaluée de l&#8217;expression doit être logique(true ou false).</p>
<p>Les opérateurs logiques disponibles sont =, !=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=, LIKE,
ILIKE, BETWEEN et IN.</p>
<p>La plupart des opérateurs s&#8217;expliquent par eux-mêmes, mais il n&#8217;est pas évident
que &#8216;&#8217;!=&#8217;&#8217; ne soit pas équivalent à &#8216;&#8217;&lt;&gt;&#8217;&#8216;, la chaine égalité n&#8217;est pas sensible
à la casse, mais les opérateurs &lt;, &gt;, &lt;= et &gt;= sont sensible à la casse. À la
fois LIKE et ILIKE sont insensible à la casse.</p>
<p>L&#8217;argument valeur à l&#8217;opérateur LIKE est un motif avec lequel la chaine de valeur
est recherché. Dans ce motif le signe pourcentage (%) correspond à un nombre de
caractères, et underscore (_) correspond à un seul caractère. Une clause
optionnelle ESCAPE <em>escape_char</em> peut être ajoutée afin que les caractères % ou
_ puissent être recherchés comme caractères normaux, en étant précédé de
<em>escape_char</em>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="30%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" rowspan="2">String</th>
<th class="head" rowspan="2">Pattern</th>
<th class="head" rowspan="2">Matches?</th>
</tr>
<tr></tr>
</thead>
<tbody valign="top">
<tr><td rowspan="2">Alberta</td>
<td rowspan="2">ALB%</td>
<td rowspan="2">Yes</td>
</tr>
<tr></tr>
<tr><td rowspan="2">Alberta</td>
<td rowspan="2">_lberta</td>
<td rowspan="2">Yes</td>
</tr>
<tr></tr>
<tr><td rowspan="2">St. Alberta</td>
<td rowspan="2">_lberta</td>
<td rowspan="2">No</td>
</tr>
<tr></tr>
<tr><td rowspan="2">St. Alberta</td>
<td rowspan="2">%lberta</td>
<td rowspan="2">Yes</td>
</tr>
<tr></tr>
<tr><td rowspan="2">Robarts St.</td>
<td rowspan="2">%Robarts%</td>
<td rowspan="2">Yes</td>
</tr>
<tr></tr>
<tr><td rowspan="2">12345</td>
<td rowspan="2">123%45</td>
<td rowspan="2">Yes</td>
</tr>
<tr></tr>
<tr><td rowspan="2">123.45</td>
<td rowspan="2">12?45</td>
<td rowspan="2">No</td>
</tr>
<tr></tr>
<tr><td rowspan="2">N0N 1P0</td>
<td rowspan="2">%N0N%</td>
<td rowspan="2">Yes</td>
</tr>
<tr></tr>
<tr><td rowspan="2">L4C 5E2</td>
<td rowspan="2">%N0N%</td>
<td rowspan="2">No</td>
</tr>
<tr></tr>
</tbody>
</table>
<p>L&#8217;opérateur IN prendre une liste de valeur comme argument et teste la présence
dans cet ensemble de la valeur de l&#8217;attribut.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="49%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" rowspan="2">Value</th>
<th class="head" rowspan="2">Value Set</th>
<th class="head" rowspan="2">Matches?</th>
</tr>
<tr></tr>
</thead>
<tbody valign="top">
<tr><td rowspan="2">321</td>
<td rowspan="2">IN (456,123)</td>
<td rowspan="2">No</td>
</tr>
<tr></tr>
<tr><td rowspan="2">&#8220;Ontario&#8221;</td>
<td rowspan="2">IN (&#8220;Ontario&#8221;,&#8221;BC&#8221;)</td>
<td rowspan="2">Yes</td>
</tr>
<tr></tr>
<tr><td rowspan="2">&#8220;Ont&#8221;</td>
<td rowspan="2">IN (&#8220;Ontario&#8221;,&#8221;BC&#8221;)</td>
<td rowspan="2">No</td>
</tr>
<tr></tr>
<tr><td rowspan="2">1</td>
<td rowspan="2">IN (0,2,4,6)</td>
<td rowspan="2">No</td>
</tr>
<tr></tr>
</tbody>
</table>
<p>La syntaxe de l&#8217;opérateur BETWEEN est &#8220;<em>field_name BETWEEN value1 AND value2</em>&#8221; et
il est équivalent à &#8220;<em>field_name &gt;= value1 AND field_name &lt;= value2</em>&#8221;.</p>
<p>En plus des opérateurs binaire ci-dessus, il y a des opérateurs additionnels
pour tester si un champ est null ou pas. Ce sont les opérateursIS NULL et IS
NOT NULL.</p>
<p>Les tests de champ basic peuvent être combiné dans des prédicats plus compliqué
en utilisant les opérateurs logique AND, OR, et le prédicat logique unaire NOT.
Les sous-expressions doivent être mis entre parenthèse pour permettre une claire
priorité. quelques prédicats plus compliqués :</p>
<div class="highlight-python"><pre>SELECT * FROM poly WHERE (prop_value &gt;= 100000) AND (prop_value &lt; 200000)
SELECT * FROM poly WHERE NOT (area_code LIKE "N0N%")
SELECT * FROM poly WHERE (prop_value IS NOT NULL) AND (prop_value &lt; 100000)</pre>
</div>
</div>
<div class="section" id="limitations-de-la-clause-where">
<h3>Limitations de la clause WHERE<a class="headerlink" href="#limitations-de-la-clause-where" title="Lien permanent vers ce titre">¶</a></h3>
<ul class="simple">
<li>Les champs doivent tous venir de la table primaire (celle listée dans la
clause FROM.</li>
<li>Toutes les comparaisons de chaine sont insensible à la casse sauf pour &lt;, &gt;,
&lt;= et &gt;=.</li>
</ul>
</div>
<div class="section" id="order-by">
<h3>ORDER BY<a class="headerlink" href="#order-by" title="Lien permanent vers ce titre">¶</a></h3>
<p>La clause ORDER BY est utilisé pour forcer les objets renvoyés à être ordonné
(ascendant ou descendant) sur un des champs. L&#8217;ordre ascendant (augmentant) est
celui par défaut si aucun des mot-clés ASC ou DESC n&#8217;est fournie. Par exemple :</p>
<div class="highlight-python"><pre>SELECT * FROM property WHERE class_code = 7 ORDER BY prop_value DESC
SELECT * FROM property ORDER BY prop_value
SELECT * FROM property ORDER BY prop_value ASC
SELECT DISTINCT zip_code FROM property ORDER BY zip_code</pre>
</div>
<p>Notez que les clauses ORDER BY entraine de passage sur l&#8217;ensemble des objets. Le
premier pour construire la table des valeurs correspondantes des champs en
mémoire avec l&#8217;id des objets, et le second passage pour récupérer les objets par
id dans l&#8217;ordre. Pour les formats dont les id des objets ne peuvent pas être lu
efficacement d&#8217;une manière aléatoire cela peut être une opération couteuse.</p>
<p>L&#8217;ordonnancement de valeurs de champs de type chaine est sensible à la casse, et
pas insensible à la casse comme dans la plupart des cas dans SQL d&#8217;OGR.</p>
</div>
<div class="section" id="clause-join">
<h3>Clause JOIN<a class="headerlink" href="#clause-join" title="Lien permanent vers ce titre">¶</a></h3>
<p>SQL d&#8217;OGR gère une forme limité de jointure une à une. Cela permet à des
enregistrements d&#8217;une table secondaire d&#8217;être utilisé pour la recherche avec une
clé partagée entre elle et la table primaire lors d&#8217;une requête. Par exemple,
une table de location de ville pourrait inclure une colonne <em>nation_id</em> qui peut
être utilisé comme référence dans une table <em>nation</em> secondaire pour récupérer
les noms des pays. Une requête par jointure pourrait ressembler à ceci :</p>
<div class="highlight-python"><pre>SELECT city.*, nation.name FROM city
 LEFT JOIN nation ON city.nation_id = nation.id</pre>
</div>
<p>Cette requête renverrait une table avec tous les champs de la table <em>city</em>, et
un champ supplémentaire <em>nation.name</em> avec le pays à l&#8217;intérieur récupérer de
la table <em>nation</em> en cherchant les enregistrements dans la table nation qui ont
le champ <em>id</em> avec la même valeur que le champ <em>city.nation_id</em>.</p>
<p>Les jointures introduisent des problèmes supplémentaires. Parmi ceux là le
concept de référencement de table sur les noms de champ. Par exemple, se référer
à <em>city.nation_id</em> plutôt que juste <em>nation_id</em> pour indiquer le champ
<em>nation_id</em> de la couche <em>city</em>. La référence du nom de la table peut seulement
être utilisé dans la liste des champs, et dans la clause ON d&#8217;une jointure.</p>
<p>Les caractères de substitution sont parfois impliqué. Tous les champs d&#8217;une
table primaire (<em>city</em> dans notre cas) et la table secondaire (<em>nation</em> dans ce
cas) peuvent être sélectionné en utilisant le caractère * de substitution. Mais
les champs d&#8217;une seul table primaire ou secondaire peuvent être sélectionné en
préfixant l&#8217;astérix avec le nom de la table.</p>
<p>Les noms des champs dans la couche de la requête résultante sera qualifié du nom
de la table, si le nom de la table est donné comme référence dans la liste des
champs. De plus les noms des champs seront qualifiés avec un nom de table s&#8217;ils
ne rentrent pas en conflit avec un nom de champs existant. Par exemple, la
requête select suivante pourrait résulter dans un ensemble de champ <em>name</em>,
<em>nation_id</em>, <em>nation.nation_id</em> et <em>nation.name</em> si les tables <em>city</em> et
<em>nation</em> ont tout deux le champs <em>nation_id</em> et <em>names</em>.</p>
<div class="highlight-python"><pre>SELECT * FROM city LEFT JOIN nation ON city.nation_id = nation.nation_id</pre>
</div>
<p>D&#8217;un autre côté si la table <em>nation</em> a un champ <em>continent_id</em> mais pas la table
<em>city</em>, alors ce champs ne nécessitera pas d&#8217;être référencé dans l&#8217;ensemble de
résultat. Cependant, si la requête select ressemble à la commande suivante, tous
les champs résultant seront référencés par le nom de la table :</p>
<div class="highlight-python"><pre>SELECT city.*, nation.* FROM city
    LEFT JOIN nation ON city.nation_id = nation.nation_id</pre>
</div>
<p>Dans les exemples au-dessus, la table <em>nation</em> a été trouvé dans la même source
de données que la table <em>city</em>. Cependant, la gestion de jointure d&#8217;OGR inclus
la possibilité de joindre une table dans une source de données différente,
éventuellement d&#8217;un format différent. Cela est indiqué en référençant la table
secondaire avec le nom d&#8217;une source de données. Dans ce cas la source de
données secondaire est ouverte en utilisant une sémantique normale d&#8217;OGR et
utilisée pour accéder à la table secondaire jusqu&#8217;à ce que le résultat de la
requête n&#8217;est plus nécessaire.</p>
<div class="highlight-python"><pre>SELECT * FROM city
    LEFT JOIN '/usr2/data/nation.dbf'.nation ON city.nation_id = nation.nation_id</pre>
</div>
<p>Bien que pas forcément nécessaire, il est également possible d&#8217;introduire des
alias de table pour simplifier certaines requêtes SELECT. Cela peut aussi être
utile pour enlever tout ambigüité lorsque des tables de même noms sont utilisé
de différents sources de données. Par exemple, si les noms des tables réels
n&#8217;étaient pas soignées nous voudrions réaliser quelque chose comme :</p>
<div class="highlight-python"><pre>SELECT c.name, n.name FROM project_615_city c
    LEFT JOIN '/usr2/data/project_615_nation.dbf'.project_615_nation n
        ON c.nation_id = n.nation_id</pre>
</div>
<p>Il est possible de réaliser des jointures multiples dans une seule requête :</p>
<div class="highlight-python"><pre>SELECT city.name, prov.name, nation.name FROM city
    LEFT JOIN province ON city.prov_id = province.id
    LEFT JOIN nation ON city.nation_id = nation.id</pre>
</div>
</div>
<div class="section" id="limitations-de-la-clause-join">
<h3>Limitations de la clause JOIN<a class="headerlink" href="#limitations-de-la-clause-join" title="Lien permanent vers ce titre">¶</a></h3>
<ul class="simple">
<li>Les jointures peuvent être des opérations couteuses si la table secondaire
n&#8217;est pas indexée sur le champ clé de la jointure.</li>
<li>Les champs joins ne peuvent pas être utilisés dans les clauses WHERE, ou ORDER
BY en même temps. La jointure est essentiellement évalué après que tous les
sous-ensemble des tables primaires soient complète et après le passage du
ORDER BY.</li>
<li>Les champs joins ne peuvent pas être utilisé comme clé dans une future
jointure. Vous ne pouvez donc pas utiliser l&#8217;id de la province dans une ville
pour rechercher les données de la provinces, puis utiliser un id d&#8217;un pays à
partir de la province pour récupérer les données du pays. Cela est quelque
chose qui pourrait être développé, mais n&#8217;est pas actuellement géré.</li>
<li>Les noms des sources de données pour les tables jointes sont évalué par
rapport au répertoire de travail du processus en cours, et pas du chemin de
la source de données primaire.</li>
<li>Il n&#8217;y a pas de réelle jointure LEFT ou RIGHT au sens RDBMS. Qu&#8217;un
enregistrement secondaire existe ou non, une et une seule copie de
l&#8217;enregistrement primaire est renvoyée dans l&#8217;ensemble des résultats. Si un
enregistrement secondaire nepeut pas être trouvé, les champs dérivés
secondaires sera NULL. Si plus d&#8217;une correspondance du champs secondaire est
trouvé, seul le premier enregistrement sera utilisé.</li>
</ul>
</div>
</div>
<div class="section" id="champs-speciaux">
<h2>Champs spéciaux<a class="headerlink" href="#champs-speciaux" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le processeur de requête SLQ d&#8217;OGR traite certains attributs d&#8217;objets comme des
champs spéciaux interne et peuvent être utilisé dans les requêtes SQL comme tout
autres champs. Ces champs peuvent être placé dans la liste des select, les
clauses WHERE et ORDER BY. Les champs spéciaux ne seront pas inclus dans le
résultat par défaut mais ils peuvent être explicitement inclus en les ajoutant
à la liste du select. Lors de l&#8217;accès à la valeur du champ les champs spéciaux
prennent la priorité sur tous les autres champs avec le même nom dans la source
de données.</p>
<div class="section" id="fid">
<h3>FID<a class="headerlink" href="#fid" title="Lien permanent vers ce titre">¶</a></h3>
<p>Normalement l&#8217;id de l&#8217;objet est une propriété spéciale d&#8217;un objet et n&#8217;est pas
traité comme un attribut d&#8217;objet. Dans certains cas il est pratique de pouvoir
utiliser l&#8217;id de l&#8217;objet dans des requêtes et des résultats comme un champ
normal. Pour cela utiliser le nom FID. L&#8217;utilisation du caractère de
substitution de champ n&#8217;inclura pas l&#8217;id de l&#8217;objet, mais il peut être
explicitement inclus en utilisant la syntaxe suivante :</p>
<div class="highlight-python"><pre>SELECT FID, * FROM nation</pre>
</div>
</div>
<div class="section" id="ogr-geometry">
<h3>OGR_GEOMETRY<a class="headerlink" href="#ogr-geometry" title="Lien permanent vers ce titre">¶</a></h3>
<p>Certaines sources de donnés (comme les fichiers tab de MapInfo) peuvent prendre
en charge des géométries de différents types dans la même couche. Le champ
spécial <em>OGR_GEOMETRY</em> représente le type de géométrie renvoyé par la méthode
<em>OGRGeometry::getGeometryName()</em> et peut être utilisé pour distinguer les
différents types. En utilisant ce champ on peut sélectionner des types
particulier des géométries :</p>
<div class="highlight-python"><pre>SELECT * FROM nation WHERE OGR_GEOMETRY='POINT' OR OGR_GEOMETRY='POLYGON'</pre>
</div>
</div>
<div class="section" id="ogr-geom-wkt">
<h3>OGR_GEOM_WKT<a class="headerlink" href="#ogr-geom-wkt" title="Lien permanent vers ce titre">¶</a></h3>
<p>La représentation <em>Well Known Text</em> d&#8217;une géométrie peut aussi être utilisé
comme champ spécial. Pour sélectionner le WKT d&#8217;une géométrie <em>OGR_GEOM_WKT</em>
peut être inclus dans la liste de select :</p>
<div class="highlight-python"><pre>SELECT OGR_GEOM_WKT, * FROM nation</pre>
</div>
<p>En utilisant <em>OGR_GEOM_WKT</em> et l&#8217;opérateur LIKE dans la clause WHERE nous
pouvons avoir des effets similaire à l&#8217;utilisation de <em>OGR_GEOMETRY</em> :</p>
<div class="highlight-python"><pre>SELECT OGR_GEOM_WKT, * FROM nation WHERE OGR_GEOM_WKT
    LIKE 'POINT%' OR OGR_GEOM_WKT LIKE 'POLYGON%'</pre>
</div>
</div>
<div class="section" id="ogr-geom-area">
<h3>OGR_GEOM_AREA<a class="headerlink" href="#ogr-geom-area" title="Lien permanent vers ce titre">¶</a></h3>
<p>(à partir de GDAL 1.7.0)</p>
<p>Le champ spécial <strong>OGR_GEOM_AREA</strong> retourne la surface de la géométrie de la
feature calculée par la méthode <em>OGRSurface::get_Area()</em>. Pour
<em>OGRGeometryCollection</em> et <em>OGRMultiPolygon</em> la valeur est la somme des surface
de ses membres. Pour les géométries non surfacique la surface retournée est 0.0.</p>
<p>Par exemple, pour sélectionner seulement les polygones plus grand qu&#8217;une surface
donnée :</p>
<div class="highlight-python"><pre>SELECT * FROM nation WHERE OGR_GEOM_AREA &gt; 10000000'</pre>
</div>
</div>
<div class="section" id="ogr-style">
<h3>OGR_STYLE<a class="headerlink" href="#ogr-style" title="Lien permanent vers ce titre">¶</a></h3>
<p>Le champs spécial <em>OGR_STYLE</em> représente la chaine de style d&#8217;un objet renvoyé
par la méthode <em>OGRFeature::GetStyleString()</em>. En utilisant ce champ et
l&#8217;opérateur LIKE le résultat d&#8217;une requête peut être filtré par le style. Par
exemple nous pouvons sélectionner  l&#8217;objet annotation avec :</p>
<div class="highlight-python"><pre>SELECT * FROM nation WHERE OGR_STYLE LIKE 'LABEL%'</pre>
</div>
</div>
</div>
<div class="section" id="create-index">
<h2>CREATE INDEX<a class="headerlink" href="#create-index" title="Lien permanent vers ce titre">¶</a></h2>
<p>Certains pilotes SQL d&#8217;OGR gère la création d&#8217;indexes attributaires. Pour
l&#8217;instant cela inclus le pilote Shapefile. Un inde accélère  les requêtes
attributaires de la forme <em>nomChamp = valeur</em>, ce qui est utilisé par la
jointure. Pour créer un index attributaire sur le champs <em>nation_id</em> de la
table <em>nation</em> une commande telle que celle-ci peut être utilisée :</p>
<div class="highlight-python"><pre>CREATE INDEX ON nation USING nation_id</pre>
</div>
<div class="section" id="limitations-des-index">
<h3>Limitations des Index<a class="headerlink" href="#limitations-des-index" title="Lien permanent vers ce titre">¶</a></h3>
<ul class="simple">
<li>Les index ne sont pas maintenu dynamiquement lors de l&#8217;ajout ou la
suppression d&#8217;une couche d&#8217;un nouvel objet.</li>
<li>Les chaines très longue (plus longue que 256 caractères) ne peuvent pas
pour l&#8217;instant être indexé.</li>
<li>Pour recréer un index il est nécessaire de supprimer tous les indexes sur
la couche et de toutes les recréer.</li>
<li>Les indexes ne sont pas utilisés dans toutes les requêtes complexes. Pour
l&#8217;instant la seule requête qui sera accélérée est la requête simple <em>champ =
valeur</em>.</li>
</ul>
</div>
</div>
<div class="section" id="drop-index">
<h2>DROP INDEX<a class="headerlink" href="#drop-index" title="Lien permanent vers ce titre">¶</a></h2>
<p>La commande SQL d&#8217;OGR DROP INDEX peut être utilisé pour supprimer tous les
indexes sur une table particulière ou juste l&#8217;index d&#8217;une colonne particulière.</p>
<div class="highlight-python"><pre>DROP INDEX ON nation USING nation_id
DROP INDEX ON nation</pre>
</div>
</div>
<div class="section" id="executesql">
<h2>ExecuteSQL()<a class="headerlink" href="#executesql" title="Lien permanent vers ce titre">¶</a></h2>
<p>SQL est exécuté en fonction de <em>OGRDataSource,</em>, et pas en fonction d&#8217;une couche
spécifique. L&#8217;appel ressemblera à ceci :</p>
<div class="highlight-python"><pre>OGRLayer * OGRDataSource::ExecuteSQL( const char *pszSQLCommand,
                                  OGRGeometry *poSpatialFilter,
                                  const char *pszDialect );</pre>
</div>
<p>L&#8217;argument <em>pszDialect</em> a pour objectif théorique de permettre la gestion de
différents langages de commande en fonction d&#8217;un provider, mais pour l&#8217;instant
les applications doivent toujours passer une chaine vide (pas NULL) pour avoir
le dialecte par défaut.</p>
<p>L&#8217;argument <em>poSpatialFilter</em> est une géométrie utilisé pour sélectionner un
rectangle de limite pour les objets à renvoyés d&#8217;une manière similaire à la
méthode <em>OGRLayer::SetSpatialFilter()</em>. Il peut être NULL pour aucune
restriction spatiale.</p>
<p>Le résultat d&#8217;un appel <em>ExecuteSQL()</em> est habituellement un OGRLayer temporaire
représentant l&#8217;ensemble des résultats de la requête. C&#8217;est le cas des requêtes
SELECT par exemple. La couche temporaire renvoyée doit être publiée avec la
méthode <em>OGRDataSource::ReleaseResultsSet()</em> quand elle n&#8217;est plus nécessaire.
L&#8217;échec de la publication avant que la source de données ne soit détruite
entrainera un crash.</p>
</div>
<div class="section" id="sql-hors-ogr">
<h2>SQL hors OGR<a class="headerlink" href="#sql-hors-ogr" title="Lien permanent vers ce titre">¶</a></h2>
<p>Tous les pilotes d&#8217;OGR pour les systèmes de bases de données : MySQL, PostgreSQL
et PostGIS (<em class="xref std std-ref">gdal.ogr.formats.postgresql</em>), Oracle
(<a class="reference internal" href="formats/oci.html#gdal-ogr-formats-oci"><em>Oracle Spatial</em></a>), SQLite, ODBC; les Géodatabases Personnelles d&#8217;ESRI
(<a class="reference internal" href="formats/pgeo.html#gdal-ogr-formats-pgeo"><em>ESRI Personal GeoDatabase</em></a>) et MS SQL Spatial (<a class="reference internal" href="formats/mssqlspatial.html#gdal-ogr-formats-mssqlspatial"><em>MSSQLSpatial - Microsoft SQL Server Spatial Database</em></a>)
écrasent la fonction <em>OGRDataSource::ExecuteSQL()</em> par une
implémentation dédiée et, par défaut, envoie les requêtes SQL directement au
RDBMS sous-jacent. Dans ces cas la syntaxe SQL varie plus ou moins du SQL d&#8217;OGR.
Aussi, tout ce qui est possible en SQL peut alors être accomplie pour ces bases
de données particulières. Seul le résultat des requêtes WHERE SQL sera renvoyé
comme des couches.</p>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../python/index.html" title="Python"
             >suivant</a></li>
        <li class="right" >
          <a href="formats/xplane.html" title="X-Plane/Flightgear aeronautical data"
             >précédent</a> |</li>
        <li><a href="../index.html">GDAL v1.9.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >OGR</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    <a href="http://creativecommons.org/licenses/by/2.0/fr/deed.fr">Licence Creative Common BY</a>
    <!--
      &copy; Copyright 2011, Yves Jacolin.-->
      Créé avec <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>